# 实施计划：[功能]

**分支**：`[###-功能名称]` | **日期**：[日期] | **规范**：[链接]
**输入**：来自`/specs/[###-功能名称]/spec.md`的功能规范

## 执行流程（/plan命令范围）
```
1. 从输入路径加载功能规范
   → 如果未找到：错误"在{路径}处没有功能规范"
2. 填充技术上下文（扫描需要澄清的内容）
   → 从上下文检测项目类型（web=前端+后端，mobile=应用+API）
   → 根据项目类型设置结构决策
3. 根据章程文档内容填充章程检查部分
4. 评估下面的章程检查部分
   → 如果存在违规：在复杂性跟踪中记录
   → 如果无法证明合理性：错误"首先简化方法"
   → 更新进度跟踪：初始章程检查
5. 执行阶段0 → research.md
   → 如果仍有需要澄清：错误"解决未知问题"
6. 执行阶段1 → contracts、data-model.md、quickstart.md、代理特定模板文件（例如，Claude Code的`CLAUDE.md`，GitHub Copilot的`.github/copilot-instructions.md`，Gemini CLI的`GEMINI.md`，Qwen Code的`QWEN.md`或opencode的`AGENTS.md`）
7. 重新评估章程检查部分
   → 如果有新违规：重构设计，返回阶段1
   → 更新进度跟踪：设计后章程检查
8. 规划阶段2 → 描述任务生成方法（不要创建tasks.md）
9. 停止 - 准备执行/tasks命令
```

**重要**：/plan命令在第7步停止。阶段2-4由其他命令执行：
- 阶段2：/tasks命令创建tasks.md
- 阶段3-4：实施执行（手动或通过工具）

## 摘要
[从功能规范提取：主要需求 + 研究中的技术方法]

## 技术上下文
**语言/版本**：[例如，Python 3.11、Swift 5.9、Rust 1.75或需要澄清]  
**主要依赖**：[例如，FastAPI、UIKit、LLVM或需要澄清]  
**存储**：[如果适用，例如，PostgreSQL、CoreData、文件或N/A]  
**测试**：[例如，pytest、XCTest、cargo test或需要澄清]  
**目标平台**：[例如，Linux服务器、iOS 15+、WASM或需要澄清]
**项目类型**：[single/web/mobile - 确定源结构]  
**性能目标**：[特定领域，例如，1000 req/s、10k lines/sec、60 fps或需要澄清]  
**约束**：[特定领域，例如，<200ms p95、<100MB内存、离线能力或需要澄清]  
**规模/范围**：[特定领域，例如，10k用户、1M LOC、50个屏幕或需要澄清]

## 章程检查
*门控：必须在阶段0研究之前通过。在阶段1设计后重新检查。*

[根据章程文件确定的门控]

## 项目结构

### 文档（此功能）
```
specs/[###-功能]/
├── plan.md              # 此文件（/plan命令输出）
├── research.md          # 阶段0输出（/plan命令）
├── data-model.md        # 阶段1输出（/plan命令）
├── quickstart.md        # 阶段1输出（/plan命令）
├── contracts/           # 阶段1输出（/plan命令）
└── tasks.md             # 阶段2输出（/tasks命令 - 不由/plan创建）
```

### 源代码（仓库根目录）
```
# 选项1：单一项目（默认）
src/
├── models/
├── services/
├── cli/
└── lib/

tests/
├── contract/
├── integration/
└── unit/

# 选项2：Web应用程序（当检测到"前端"+"后端"时）
backend/
├── src/
│   ├── models/
│   ├── services/
│   └── api/
└── tests/

frontend/
├── src/
│   ├── components/
│   ├── pages/
│   └── services/
└── tests/

# 选项3：移动端+API（当检测到"iOS/Android"时）
api/
└── [与上面后端相同]

ios/ 或 android/
└── [平台特定结构]
```

**结构决策**：[默认为选项1，除非技术上下文指示web/mobile应用]

## 阶段0：概述与研究
1. **从上面的技术上下文中提取未知内容**：
   - 对于每个需要澄清 → 研究任务
   - 对于每个依赖 → 最佳实践任务
   - 对于每个集成 → 模式任务

2. **生成并派遣研究代理**：
   ```
   对于技术上下文中的每个未知：
     任务："为{功能上下文}研究{未知}"
   对于每个技术选择：
     任务："在{领域}中为{技术}找到最佳实践"
   ```

3. **在`research.md`中整合发现**，使用格式：
   - 决策：[选择了什么]
   - 理由：[为什么选择]
   - 考虑的替代方案：[还评估了什么]

**输出**：解决所有需要澄清的research.md

## 阶段1：设计与合约
*先决条件：research.md完成*

1. **从功能规范提取实体** → `data-model.md`：
   - 实体名称、字段、关系
   - 来自需求的验证规则
   - 如果适用的状态转换

2. **从功能需求生成API合约**：
   - 对于每个用户操作 → 端点
   - 使用标准REST/GraphQL模式
   - 将OpenAPI/GraphQL模式输出到`/contracts/`

3. **从合约生成合约测试**：
   - 每个端点一个测试文件
   - 断言请求/响应模式
   - 测试必须失败（尚未实现）

4. **从用户故事提取测试场景**：
   - 每个故事 → 集成测试场景
   - 快速开始测试 = 故事验证步骤

5. **增量更新代理文件**（O(1)操作）：
   - 运行`.specify/scripts/bash/update-agent-context.sh cursor`
     **重要**：严格按照上述方式执行。不要添加或删除任何参数。
   - 如果存在：仅添加当前计划中的新技术
   - 保留标记之间的手动添加
   - 更新最近变更（保留最后3个）
   - 保持150行以下以提高令牌效率
   - 输出到仓库根目录

**输出**：data-model.md、/contracts/*、失败测试、quickstart.md、代理特定文件

## 阶段2：任务规划方法
*此部分描述/tasks命令将做什么 - 在/plan期间不要执行*

**任务生成策略**：
- 加载`.specify/templates/tasks-template.md`作为基础
- 从阶段1设计文档生成任务（合约、数据模型、快速开始）
- 每个合约 → 合约测试任务[P]
- 每个实体 → 模型创建任务[P] 
- 每个用户故事 → 集成测试任务
- 使测试通过的实现任务

**排序策略**：
- TDD顺序：测试在实现之前
- 依赖顺序：模型在服务之前，服务在UI之前
- 标记[P]用于并行执行（独立文件）

**估计输出**：tasks.md中的25-30个编号、有序任务

**重要**：此阶段由/tasks命令执行，不是/plan

## 阶段3+：未来实施
*这些阶段超出/plan命令的范围*

**阶段3**：任务执行（/tasks命令创建tasks.md）  
**阶段4**：实施（执行tasks.md遵循章程原则）  
**阶段5**：验证（运行测试、执行quickstart.md、性能验证）

## 复杂性跟踪
*仅在章程检查有必须证明的违规时填写*

| 违规 | 为什么需要 | 拒绝更简单替代方案的原因 |
|------|------------|------------------------|
| [例如，第4个项目] | [当前需求] | [为什么3个项目不够] |
| [例如，仓库模式] | [特定问题] | [为什么直接数据库访问不够] |


## 进度跟踪
*此检查清单在执行流程中更新*

**阶段状态**：
- [ ] 阶段0：研究完成（/plan命令）
- [ ] 阶段1：设计完成（/plan命令）
- [ ] 阶段2：任务规划完成（/plan命令 - 仅描述方法）
- [ ] 阶段3：任务生成（/tasks命令）
- [ ] 阶段4：实施完成
- [ ] 阶段5：验证通过

**门控状态**：
- [ ] 初始章程检查：通过
- [ ] 设计后章程检查：通过
- [ ] 所有需要澄清已解决
- [ ] 复杂性偏差已记录

---
*基于章程v2.1.1 - 参见`/memory/constitution.md`*
